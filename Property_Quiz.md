Use the solution to this afternoon’s Property Tracker lab to answer the following questions. Please write your answers under each question, push the file to GitHub, and submit in the usual way.
MVP Questions

In our Property Tracker application:

Q1. Where are we instantiating instances of the Property class?
In the property_tracker table

Q2. Where are we defining the SQL that enables us to save the ruby Property object into the database?
Within functions in properties.rb

Q3. In console.rb, which lines modify the database?
Lines with the .save method

Q4. Why do we not define the id of a Property object at the point we instantiate it (‘new it up’)?
This may conflict with an existing ID in the database. It is better to let the database generate IDs.

Q5. Where and how do we assign the id (that is generated by the database) to the ruby Property object?
When calling the object from the database, we call the object with its database-assigned ID included and this remains assigned to the 'new' Ruby object.

Q6. Why do we put a guard (an if clause) on the @id attribute in the constructor?
The constructor creates a 'new' object whenever it calls an object from the database, or initialises a new object from scratch. The guard is to differentiate between these. 'If' the object is from a database, it has an ID, and so must be created with one.

Q7. Why are some of the CRUD actions represented by instance methods, and others by class methods?
Those methods that only affect one object are better being run directly on that object.
Those that affect the entire table should be applied at the Class level.
This also allows functions that affect the table as a whole without an instance to refer to first.


Q8. What type of data structure is returned by calls to db.exec_prepared()? In the save method, how do we access the id from the returned data structure?
db.exec_prepared returns an array consisting of whatever the function has been called for in the SQL. In our save function we access this by calling the first item in that array.



Q9. Why do we use prepared statements when performing database operations?
It improves the security of the code, as SQL will be set to accept only specific returns, rather than a string which can be engineered to contain malicious code.

Extension Questions

Look at the find_by_id and find_by_address methods in the Property class.

Q10. What do they take in as their arguments?
Whatever argument is given is converted to a string if it isn't already, as this is how SQL reads it. 

Q11. What are their return values?
They return an array containing every property of the object, including its memory hash.
